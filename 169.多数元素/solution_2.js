/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    nums.sort((a, b) => a - b);
    return nums[Math.floor(nums.length / 2)];
};

// 解法：排序法
// 思路：排序后，索引为⌊n/2⌋的元素（n是数组长度），一定是多数元素
// 问：为什么这种策略是有效的？
// 答
// 情况一：n为奇数，如[1, 1, 1, 1, 2, 2, 2]，n=7
// ⌊n/2⌋=3，正好是中间的元素，无论众数是较小元素还是较大元素，都会包含中间元素

// 情况二：n为偶数，如【1, 1, 1, 1, 2, 2]， n=6
// ⌊n/2⌋=3，如果众数是较小元素，那至少要包含索引为⌊n/2⌋的元素，如果众数是较大元素，自然包含索引为⌊n/2⌋的元素

// 1. 将数组排序
// 2. 返回索引为⌊n/2⌋的元素
// 时间复杂度O(nlog n)，排序的时间复杂度是O(nlog n)
// 空间复杂度：使用语言自带排序算法，空间复杂度O(log n)，自己写堆排序，空间复杂度O(1)